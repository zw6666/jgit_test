============================================================
2020-05-07 20:13:27:zw6666
重构失败的文件:
重构信息：
文件名,问题名,问题类型,问题评注,重构信息,起始行,终止行

/DiamondTest.java,集合范性定义时没有使用diamond语法,1,集合创建时，<>内的变量类型均可以省略，使代码看起来不过于冗长，便于阅读,删除<>中的变量类型声明,11,11
/DiamondTest.java,集合范性定义时没有使用diamond语法,1,集合创建时，<>内的变量类型均可以省略，使代码看起来不过于冗长，便于阅读,删除<>中的变量类型声明,12,12
/DiamondTest.java,集合范性定义时没有使用diamond语法,1,集合创建时，<>内的变量类型均可以省略，使代码看起来不过于冗长，便于阅读,删除<>中的变量类型声明,13,13
============================================================
2020-05-07 20:14:21:zw6666
重构失败的文件:
重构信息：
文件名,问题名,问题类型,问题评注,重构信息,起始行,终止行

============================================================
2020-05-08 14:48:49:zw6666
重构失败的文件:
重构信息：
文件名,问题名,问题类型,问题评注,重构信息,起始行,终止行

/test/StaticVariabTest.java,避免通过一个类的对象引用访问此类的静态变量,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态变量，需要人工辅助重构,8,8
/test/StaticVariabTest.java,避免通过一个类的对象引用访问此类的静态变量,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态变量，需要人工辅助重构,9,9
/test/StaticVariabTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,24,24
/test/EqualsTest.java,不要引入Sun包,2,这些包不是轻便的而且可能更改，且与操作系统相关,考虑该包是否为必须引入，需人工辅助重构,3,3
/test/BigDecimalTest.java,不要创建已经存在的BigDecimal类型的实例(BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN),3,避免创建已经存在的BigDecimal对象，造成系统资源的浪费,考虑用存在的BigDecimal类型的实例(BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN)替换，需手工辅助重构,7,7
/test/IFTest.java,避免接口包含常量,2,常量接口模式是对接口的不良使用，接口仅仅是应该用来处理对象提供的service而不是data，这样会导致把这样的实现细节泄露到该类的导出API中,涉及程序的算法逻辑，需人工辅助重构,4,4
/test/IFTest.java,避免接口包含常量,2,常量接口模式是对接口的不良使用，接口仅仅是应该用来处理对象提供的service而不是data，这样会导致把这样的实现细节泄露到该类的导出API中,涉及程序的算法逻辑，需人工辅助重构,5,5
/test/ThrowableTest.java,catch到异常，不要用printStackTrace()方法，建议用日志log打印出来,3,printStackTrace()默认使用了System.err输出流进行输出，与System.out是两个不同的输出流，那么在打印时自然就形成了交叉,在并发大日志输出多的情况下，查看异常日志就变更的非常困难,影响程序性能的风格问题的重构需要人工辅助判断，直接重构有影响程序运行的风险,11,11
/test/ThrowableTest.java,catch到异常，不要用printStackTrace()方法，建议用日志log打印出来,3,printStackTrace()默认使用了System.err输出流进行输出，与System.out是两个不同的输出流，那么在打印时自然就形成了交叉,在并发大日志输出多的情况下，查看异常日志就变更的非常困难,影响程序性能的风格问题的重构需要人工辅助判断，直接重构有影响程序运行的风险,18,18
/test/JdtTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,4,4
/test/JdtTest.java,避免实例化String对象,3,String类的设计使用了一个共享设计模式，在JVM的底层实际上会自动维护一个对象池（现在是字符串对象池），如果采用直接赋值的模式进行String类对象的实例化操作，那么该实例化对象（字符串内容）将自动的保存到这个对象池之中，如果下次继续 有人使用了直接赋值的模式声明了String类的对象，那么如果此时对象池之中由指定的内容，那么将直接进行引用，如果没有，则开辟新的字符串对象，而后将其保存在对象池之中，以供下次使用,需要结合String实例化场景判断，需人工辅助重构,99,99
/test/SwitchTest.java,在Switch语句中，每个Case应该包含return或break，否则注释说明程序将继续执行到哪一个case为止,2,如果一个case分支的代码中缺少break、return就会导致跨越分支，如果不是有注释的有意图的分支跨越就可能导致潜在的程序错误,case分支添加break，return语句会改变程序运行逻辑，且与开发人员的编程习惯有关，需人工辅助重构,21,21
/test/SwitchTest.java,相同的字符串常量出现次数过多(>4)，考虑用常量替换：ccc,1,字符串重复出现对程序可读性有很大影响，使得维护工作变得更加困难，如果要修改内容需逐个修改，耗费时间且扩展性差,人工辅助重构（考虑用常量替换）,1,-1
/test/ForeachTest.java,在foreach循环里进行remove/add操作,2,cursor：下一个元素的索引位置(调用Interator.next()是会触发cursor+1),如果我们我们用foreach删除的元素刚好是最后一个，删除完成前cursor刚好等于size的大小。但是，删除完成后size的数量减1，但是cursor并没有变化。Iterator.hasNext(){return cursor!=size},导致下一次循环不相等继续向下执行，导致检查数组不通过,涉及程序算法逻辑，直接修改可能引入新问题，需人工辅助重构,16,16
/test/ForeachTest.java,在foreach循环里进行remove/add操作,2,cursor：下一个元素的索引位置(调用Interator.next()是会触发cursor+1),如果我们我们用foreach删除的元素刚好是最后一个，删除完成前cursor刚好等于size的大小。但是，删除完成后size的数量减1，但是cursor并没有变化。Iterator.hasNext(){return cursor!=size},导致下一次循环不相等继续向下执行，导致检查数组不通过,涉及程序算法逻辑，直接修改可能引入新问题，需人工辅助重构,17,17
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,5,5
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,6,6
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,7,7
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,10,10
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,11,11
/test/LongTypeTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,11,11
/test/AstTest.java,避免通过一个类的对象引用访问此类的静态方法,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态方法，需要人工辅助重构,33,33
/test/AstTest.java,避免通过一个类的对象引用访问此类的静态方法,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态方法，需要人工辅助重构,34,34
/test/AstTest.java,避免通过一个类的对象引用访问此类的静态方法,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态方法，需要人工辅助重构,50,50
/test/AstTest.java,不要在finally抛出异常，这样可能会掩盖异常抛出,2,finally里面不要抛出异常，因为程序的输出以finally块为准，假如catch语句也抛出了异常，那么上面一层代码只能收到finally里面抛出的异常，而catch抛出的异常将丢失掉，这个导致异常的错误情况将很难发现和定位,该代码风格问题涉及程序逻辑,直接删除容易引入新的问题，需人工辅助重构,63,63
/test/AstTest.java,避免在finally块中使用return语句,2,finally语句块中的return语句的优先级最高，程序会优先返回finally语句块中的立即结束语句的结果，此时try-catch语句块中的return的结果无效，被覆盖了,该代码风格问题涉及程序逻辑,直接return语句删除容易引入新的问题，需人工辅助重构,67,67
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,10,10
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,20,20
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,29,29
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,30,30
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,31,31
/test/AstTest.java,If表达式中的&&、||、&、|的数量过多，超过4个,4,如果条件分支里的表达式过于复杂，出现了太多的&&、||、&、|，这段代码的可读性就会大打折扣，容易产生逻辑错误且异常的错误情况将很难发现和定位,考虑简化表达式或提出表达式语句,需人工辅助重构,36,38
/test/AstTest.java,catch到异常，不要用printStackTrace()方法，建议用日志log打印出来,3,printStackTrace()默认使用了System.err输出流进行输出，与System.out是两个不同的输出流，那么在打印时自然就形成了交叉,在并发大日志输出多的情况下，查看异常日志就变更的非常困难,影响程序性能的风格问题的重构需要人工辅助判断，直接重构有影响程序运行的风险,56,56
/test/SystemExitTest.java,不要请求System.exit(),2,web应用不该调用System.exit(),因为只有web容器或应用服务器才能停止JVM,是否是有意图的停止JVM，需人工辅助重构,6,6
/test/SystemExitTest.java,不要请求Runtime.getRuntime().exit(),2,web应用不该调用Runtime.getRuntime().exit(),因为只有web容器或应用服务器才能停止JVM,是否是有意图的停止JVM，需人工辅助重构,7,7
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,18,18
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,19,19
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,22,22
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,23,23
/test/StringTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,5,5
/test/StringTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,6,6
/test/StringTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,7,7
/test/StringTest.java,不要引入Sun包,2,这些包不是轻便的而且可能更改，且与操作系统相关,考虑该包是否为必须引入，需人工辅助重构,7,7
/test/StringTest.java,不要引入Sun包,2,这些包不是轻便的而且可能更改，且与操作系统相关,考虑该包是否为必须引入，需人工辅助重构,8,8
/test/StringTest.java,避免实例化String对象,3,String类的设计使用了一个共享设计模式，在JVM的底层实际上会自动维护一个对象池（现在是字符串对象池），如果采用直接赋值的模式进行String类对象的实例化操作，那么该实例化对象（字符串内容）将自动的保存到这个对象池之中，如果下次继续 有人使用了直接赋值的模式声明了String类的对象，那么如果此时对象池之中由指定的内容，那么将直接进行引用，如果没有，则开辟新的字符串对象，而后将其保存在对象池之中，以供下次使用,需要结合String实例化场景判断，需人工辅助重构,14,14
/test/StringTest.java,避免实例化String对象,3,String类的设计使用了一个共享设计模式，在JVM的底层实际上会自动维护一个对象池（现在是字符串对象池），如果采用直接赋值的模式进行String类对象的实例化操作，那么该实例化对象（字符串内容）将自动的保存到这个对象池之中，如果下次继续 有人使用了直接赋值的模式声明了String类的对象，那么如果此时对象池之中由指定的内容，那么将直接进行引用，如果没有，则开辟新的字符串对象，而后将其保存在对象池之中，以供下次使用,需要结合String实例化场景判断，需人工辅助重构,16,16
/test/VariableDeclarationTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,5,5
/test/VariableDeclarationTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,9,9
============================================================
2020-05-08 14:51:09:zw6666
重构失败的文件:
重构信息：
文件名,问题名,问题类型,问题评注,重构信息,起始行,终止行

/test/StaticVariabTest.java,避免通过一个类的对象引用访问此类的静态变量,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态变量，需要人工辅助重构,8,8
/test/StaticVariabTest.java,避免通过一个类的对象引用访问此类的静态变量,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态变量，需要人工辅助重构,9,9
/test/StaticVariabTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,24,24
/test/EqualsTest.java,不要引入Sun包,2,这些包不是轻便的而且可能更改，且与操作系统相关,考虑该包是否为必须引入，需人工辅助重构,3,3
/test/BigDecimalTest.java,不要创建已经存在的BigDecimal类型的实例(BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN),3,避免创建已经存在的BigDecimal对象，造成系统资源的浪费,考虑用存在的BigDecimal类型的实例(BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN)替换，需手工辅助重构,7,7
/test/IFTest.java,避免接口包含常量,2,常量接口模式是对接口的不良使用，接口仅仅是应该用来处理对象提供的service而不是data，这样会导致把这样的实现细节泄露到该类的导出API中,涉及程序的算法逻辑，需人工辅助重构,4,4
/test/IFTest.java,避免接口包含常量,2,常量接口模式是对接口的不良使用，接口仅仅是应该用来处理对象提供的service而不是data，这样会导致把这样的实现细节泄露到该类的导出API中,涉及程序的算法逻辑，需人工辅助重构,5,5
/test/ThrowableTest.java,catch到异常，不要用printStackTrace()方法，建议用日志log打印出来,3,printStackTrace()默认使用了System.err输出流进行输出，与System.out是两个不同的输出流，那么在打印时自然就形成了交叉,在并发大日志输出多的情况下，查看异常日志就变更的非常困难,影响程序性能的风格问题的重构需要人工辅助判断，直接重构有影响程序运行的风险,11,11
/test/ThrowableTest.java,catch到异常，不要用printStackTrace()方法，建议用日志log打印出来,3,printStackTrace()默认使用了System.err输出流进行输出，与System.out是两个不同的输出流，那么在打印时自然就形成了交叉,在并发大日志输出多的情况下，查看异常日志就变更的非常困难,影响程序性能的风格问题的重构需要人工辅助判断，直接重构有影响程序运行的风险,18,18
/test/JdtTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,4,4
/test/JdtTest.java,避免实例化String对象,3,String类的设计使用了一个共享设计模式，在JVM的底层实际上会自动维护一个对象池（现在是字符串对象池），如果采用直接赋值的模式进行String类对象的实例化操作，那么该实例化对象（字符串内容）将自动的保存到这个对象池之中，如果下次继续 有人使用了直接赋值的模式声明了String类的对象，那么如果此时对象池之中由指定的内容，那么将直接进行引用，如果没有，则开辟新的字符串对象，而后将其保存在对象池之中，以供下次使用,需要结合String实例化场景判断，需人工辅助重构,99,99
/test/SwitchTest.java,在Switch语句中，每个Case应该包含return或break，否则注释说明程序将继续执行到哪一个case为止,2,如果一个case分支的代码中缺少break、return就会导致跨越分支，如果不是有注释的有意图的分支跨越就可能导致潜在的程序错误,case分支添加break，return语句会改变程序运行逻辑，且与开发人员的编程习惯有关，需人工辅助重构,21,21
/test/SwitchTest.java,相同的字符串常量出现次数过多(>4)，考虑用常量替换：ccc,1,字符串重复出现对程序可读性有很大影响，使得维护工作变得更加困难，如果要修改内容需逐个修改，耗费时间且扩展性差,人工辅助重构（考虑用常量替换）,1,-1
/test/ForeachTest.java,在foreach循环里进行remove/add操作,2,cursor：下一个元素的索引位置(调用Interator.next()是会触发cursor+1),如果我们我们用foreach删除的元素刚好是最后一个，删除完成前cursor刚好等于size的大小。但是，删除完成后size的数量减1，但是cursor并没有变化。Iterator.hasNext(){return cursor!=size},导致下一次循环不相等继续向下执行，导致检查数组不通过,涉及程序算法逻辑，直接修改可能引入新问题，需人工辅助重构,16,16
/test/ForeachTest.java,在foreach循环里进行remove/add操作,2,cursor：下一个元素的索引位置(调用Interator.next()是会触发cursor+1),如果我们我们用foreach删除的元素刚好是最后一个，删除完成前cursor刚好等于size的大小。但是，删除完成后size的数量减1，但是cursor并没有变化。Iterator.hasNext(){return cursor!=size},导致下一次循环不相等继续向下执行，导致检查数组不通过,涉及程序算法逻辑，直接修改可能引入新问题，需人工辅助重构,17,17
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,5,5
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,6,6
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,7,7
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,10,10
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,11,11
/test/LongTypeTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,11,11
/test/AstTest.java,避免通过一个类的对象引用访问此类的静态方法,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态方法，需要人工辅助重构,33,33
/test/AstTest.java,避免通过一个类的对象引用访问此类的静态方法,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态方法，需要人工辅助重构,34,34
/test/AstTest.java,避免通过一个类的对象引用访问此类的静态方法,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态方法，需要人工辅助重构,50,50
/test/AstTest.java,不要在finally抛出异常，这样可能会掩盖异常抛出,2,finally里面不要抛出异常，因为程序的输出以finally块为准，假如catch语句也抛出了异常，那么上面一层代码只能收到finally里面抛出的异常，而catch抛出的异常将丢失掉，这个导致异常的错误情况将很难发现和定位,该代码风格问题涉及程序逻辑,直接删除容易引入新的问题，需人工辅助重构,63,63
/test/AstTest.java,避免在finally块中使用return语句,2,finally语句块中的return语句的优先级最高，程序会优先返回finally语句块中的立即结束语句的结果，此时try-catch语句块中的return的结果无效，被覆盖了,该代码风格问题涉及程序逻辑,直接return语句删除容易引入新的问题，需人工辅助重构,67,67
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,10,10
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,20,20
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,29,29
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,30,30
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,31,31
/test/AstTest.java,If表达式中的&&、||、&、|的数量过多，超过4个,4,如果条件分支里的表达式过于复杂，出现了太多的&&、||、&、|，这段代码的可读性就会大打折扣，容易产生逻辑错误且异常的错误情况将很难发现和定位,考虑简化表达式或提出表达式语句,需人工辅助重构,36,38
/test/AstTest.java,catch到异常，不要用printStackTrace()方法，建议用日志log打印出来,3,printStackTrace()默认使用了System.err输出流进行输出，与System.out是两个不同的输出流，那么在打印时自然就形成了交叉,在并发大日志输出多的情况下，查看异常日志就变更的非常困难,影响程序性能的风格问题的重构需要人工辅助判断，直接重构有影响程序运行的风险,56,56
/test/SystemExitTest.java,不要请求System.exit(),2,web应用不该调用System.exit(),因为只有web容器或应用服务器才能停止JVM,是否是有意图的停止JVM，需人工辅助重构,6,6
/test/SystemExitTest.java,不要请求Runtime.getRuntime().exit(),2,web应用不该调用Runtime.getRuntime().exit(),因为只有web容器或应用服务器才能停止JVM,是否是有意图的停止JVM，需人工辅助重构,7,7
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,18,18
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,19,19
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,22,22
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,23,23
/test/StringTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,5,5
/test/StringTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,6,6
/test/StringTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,7,7
/test/StringTest.java,不要引入Sun包,2,这些包不是轻便的而且可能更改，且与操作系统相关,考虑该包是否为必须引入，需人工辅助重构,7,7
/test/StringTest.java,不要引入Sun包,2,这些包不是轻便的而且可能更改，且与操作系统相关,考虑该包是否为必须引入，需人工辅助重构,8,8
/test/StringTest.java,避免实例化String对象,3,String类的设计使用了一个共享设计模式，在JVM的底层实际上会自动维护一个对象池（现在是字符串对象池），如果采用直接赋值的模式进行String类对象的实例化操作，那么该实例化对象（字符串内容）将自动的保存到这个对象池之中，如果下次继续 有人使用了直接赋值的模式声明了String类的对象，那么如果此时对象池之中由指定的内容，那么将直接进行引用，如果没有，则开辟新的字符串对象，而后将其保存在对象池之中，以供下次使用,需要结合String实例化场景判断，需人工辅助重构,14,14
/test/StringTest.java,避免实例化String对象,3,String类的设计使用了一个共享设计模式，在JVM的底层实际上会自动维护一个对象池（现在是字符串对象池），如果采用直接赋值的模式进行String类对象的实例化操作，那么该实例化对象（字符串内容）将自动的保存到这个对象池之中，如果下次继续 有人使用了直接赋值的模式声明了String类的对象，那么如果此时对象池之中由指定的内容，那么将直接进行引用，如果没有，则开辟新的字符串对象，而后将其保存在对象池之中，以供下次使用,需要结合String实例化场景判断，需人工辅助重构,16,16
/test/VariableDeclarationTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,5,5
/test/VariableDeclarationTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,9,9
============================================================
2020-05-08 14:51:48:zw6666
重构失败的文件:
重构信息：
文件名,问题名,问题类型,问题评注,重构信息,起始行,终止行

/test/StaticVariabTest.java,避免通过一个类的对象引用访问此类的静态变量,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态变量，需要人工辅助重构,8,8
/test/StaticVariabTest.java,避免通过一个类的对象引用访问此类的静态变量,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态变量，需要人工辅助重构,9,9
/test/StaticVariabTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,24,24
/test/EqualsTest.java,不要引入Sun包,2,这些包不是轻便的而且可能更改，且与操作系统相关,考虑该包是否为必须引入，需人工辅助重构,3,3
/test/BigDecimalTest.java,不要创建已经存在的BigDecimal类型的实例(BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN),3,避免创建已经存在的BigDecimal对象，造成系统资源的浪费,考虑用存在的BigDecimal类型的实例(BigDecimal.ZERO, BigDecimal.ONE, BigDecimal.TEN)替换，需手工辅助重构,7,7
/test/IFTest.java,避免接口包含常量,2,常量接口模式是对接口的不良使用，接口仅仅是应该用来处理对象提供的service而不是data，这样会导致把这样的实现细节泄露到该类的导出API中,涉及程序的算法逻辑，需人工辅助重构,4,4
/test/IFTest.java,避免接口包含常量,2,常量接口模式是对接口的不良使用，接口仅仅是应该用来处理对象提供的service而不是data，这样会导致把这样的实现细节泄露到该类的导出API中,涉及程序的算法逻辑，需人工辅助重构,5,5
/test/ThrowableTest.java,catch到异常，不要用printStackTrace()方法，建议用日志log打印出来,3,printStackTrace()默认使用了System.err输出流进行输出，与System.out是两个不同的输出流，那么在打印时自然就形成了交叉,在并发大日志输出多的情况下，查看异常日志就变更的非常困难,影响程序性能的风格问题的重构需要人工辅助判断，直接重构有影响程序运行的风险,11,11
/test/ThrowableTest.java,catch到异常，不要用printStackTrace()方法，建议用日志log打印出来,3,printStackTrace()默认使用了System.err输出流进行输出，与System.out是两个不同的输出流，那么在打印时自然就形成了交叉,在并发大日志输出多的情况下，查看异常日志就变更的非常困难,影响程序性能的风格问题的重构需要人工辅助判断，直接重构有影响程序运行的风险,18,18
/test/JdtTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,4,4
/test/JdtTest.java,避免实例化String对象,3,String类的设计使用了一个共享设计模式，在JVM的底层实际上会自动维护一个对象池（现在是字符串对象池），如果采用直接赋值的模式进行String类对象的实例化操作，那么该实例化对象（字符串内容）将自动的保存到这个对象池之中，如果下次继续 有人使用了直接赋值的模式声明了String类的对象，那么如果此时对象池之中由指定的内容，那么将直接进行引用，如果没有，则开辟新的字符串对象，而后将其保存在对象池之中，以供下次使用,需要结合String实例化场景判断，需人工辅助重构,99,99
/test/SwitchTest.java,在Switch语句中，每个Case应该包含return或break，否则注释说明程序将继续执行到哪一个case为止,2,如果一个case分支的代码中缺少break、return就会导致跨越分支，如果不是有注释的有意图的分支跨越就可能导致潜在的程序错误,case分支添加break，return语句会改变程序运行逻辑，且与开发人员的编程习惯有关，需人工辅助重构,21,21
/test/SwitchTest.java,相同的字符串常量出现次数过多(>4)，考虑用常量替换：ccc,1,字符串重复出现对程序可读性有很大影响，使得维护工作变得更加困难，如果要修改内容需逐个修改，耗费时间且扩展性差,人工辅助重构（考虑用常量替换）,1,-1
/test/ForeachTest.java,在foreach循环里进行remove/add操作,2,cursor：下一个元素的索引位置(调用Interator.next()是会触发cursor+1),如果我们我们用foreach删除的元素刚好是最后一个，删除完成前cursor刚好等于size的大小。但是，删除完成后size的数量减1，但是cursor并没有变化。Iterator.hasNext(){return cursor!=size},导致下一次循环不相等继续向下执行，导致检查数组不通过,涉及程序算法逻辑，直接修改可能引入新问题，需人工辅助重构,16,16
/test/ForeachTest.java,在foreach循环里进行remove/add操作,2,cursor：下一个元素的索引位置(调用Interator.next()是会触发cursor+1),如果我们我们用foreach删除的元素刚好是最后一个，删除完成前cursor刚好等于size的大小。但是，删除完成后size的数量减1，但是cursor并没有变化。Iterator.hasNext(){return cursor!=size},导致下一次循环不相等继续向下执行，导致检查数组不通过,涉及程序算法逻辑，直接修改可能引入新问题，需人工辅助重构,17,17
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,5,5
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,6,6
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,7,7
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,10,10
/test/ShortTest.java,避免使用short类型,考虑用int代替,3,建议使用int类型，在 HotSpot JVM 中int是经过特别优化的，从性能和效率上是最优的选择,数据类型切换有可能会影响数据精度，需要人工辅助判断是否需要重构,11,11
/test/LongTypeTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,11,11
/test/AstTest.java,避免通过一个类的对象引用访问此类的静态方法,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态方法，需要人工辅助重构,33,33
/test/AstTest.java,避免通过一个类的对象引用访问此类的静态方法,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态方法，需要人工辅助重构,34,34
/test/AstTest.java,避免通过一个类的对象引用访问此类的静态方法,3,这样会造成无谓增加编译器解析成本，直接用类名来访问即可,直接重构可能会影响程序逻辑和性能,且可能有多个类有同名的静态方法，需要人工辅助重构,50,50
/test/AstTest.java,不要在finally抛出异常，这样可能会掩盖异常抛出,2,finally里面不要抛出异常，因为程序的输出以finally块为准，假如catch语句也抛出了异常，那么上面一层代码只能收到finally里面抛出的异常，而catch抛出的异常将丢失掉，这个导致异常的错误情况将很难发现和定位,该代码风格问题涉及程序逻辑,直接删除容易引入新的问题，需人工辅助重构,63,63
/test/AstTest.java,避免在finally块中使用return语句,2,finally语句块中的return语句的优先级最高，程序会优先返回finally语句块中的立即结束语句的结果，此时try-catch语句块中的return的结果无效，被覆盖了,该代码风格问题涉及程序逻辑,直接return语句删除容易引入新的问题，需人工辅助重构,67,67
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,10,10
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,20,20
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,29,29
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,30,30
/test/AstTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,31,31
/test/AstTest.java,If表达式中的&&、||、&、|的数量过多，超过4个,4,如果条件分支里的表达式过于复杂，出现了太多的&&、||、&、|，这段代码的可读性就会大打折扣，容易产生逻辑错误且异常的错误情况将很难发现和定位,考虑简化表达式或提出表达式语句,需人工辅助重构,36,38
/test/AstTest.java,catch到异常，不要用printStackTrace()方法，建议用日志log打印出来,3,printStackTrace()默认使用了System.err输出流进行输出，与System.out是两个不同的输出流，那么在打印时自然就形成了交叉,在并发大日志输出多的情况下，查看异常日志就变更的非常困难,影响程序性能的风格问题的重构需要人工辅助判断，直接重构有影响程序运行的风险,56,56
/test/SystemExitTest.java,不要请求System.exit(),2,web应用不该调用System.exit(),因为只有web容器或应用服务器才能停止JVM,是否是有意图的停止JVM，需人工辅助重构,6,6
/test/SystemExitTest.java,不要请求Runtime.getRuntime().exit(),2,web应用不该调用Runtime.getRuntime().exit(),因为只有web容器或应用服务器才能停止JVM,是否是有意图的停止JVM，需人工辅助重构,7,7
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,18,18
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,19,19
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,22,22
/test/StringTest.java,方法Arrays.aslist把数组转换成集合时，不支持add和remove方法,2,这是Arrays里面的一个静态内部类，内部类没有add和remove，当然不能进行这些操作了，但是修改可以通过set方法,该代码风格问题涉及程序逻辑，需人工辅助重构,23,23
/test/StringTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,5,5
/test/StringTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,6,6
/test/StringTest.java,通配符导入，避免import语句使用*符号,3,从一个包中导入所有的类会导致包之间的紧耦合，当一个新版本的库引入了命名冲突时，这样就有可能导致问题发生,考虑单类型导入，需人工辅助重构,7,7
/test/StringTest.java,不要引入Sun包,2,这些包不是轻便的而且可能更改，且与操作系统相关,考虑该包是否为必须引入，需人工辅助重构,7,7
/test/StringTest.java,不要引入Sun包,2,这些包不是轻便的而且可能更改，且与操作系统相关,考虑该包是否为必须引入，需人工辅助重构,8,8
/test/StringTest.java,避免实例化String对象,3,String类的设计使用了一个共享设计模式，在JVM的底层实际上会自动维护一个对象池（现在是字符串对象池），如果采用直接赋值的模式进行String类对象的实例化操作，那么该实例化对象（字符串内容）将自动的保存到这个对象池之中，如果下次继续 有人使用了直接赋值的模式声明了String类的对象，那么如果此时对象池之中由指定的内容，那么将直接进行引用，如果没有，则开辟新的字符串对象，而后将其保存在对象池之中，以供下次使用,需要结合String实例化场景判断，需人工辅助重构,14,14
/test/StringTest.java,避免实例化String对象,3,String类的设计使用了一个共享设计模式，在JVM的底层实际上会自动维护一个对象池（现在是字符串对象池），如果采用直接赋值的模式进行String类对象的实例化操作，那么该实例化对象（字符串内容）将自动的保存到这个对象池之中，如果下次继续 有人使用了直接赋值的模式声明了String类的对象，那么如果此时对象池之中由指定的内容，那么将直接进行引用，如果没有，则开辟新的字符串对象，而后将其保存在对象池之中，以供下次使用,需要结合String实例化场景判断，需人工辅助重构,16,16
/test/VariableDeclarationTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,5,5
/test/VariableDeclarationTest.java,使用一行一条语句进行变量声明,提高可读性,1,增强程序可读性，方便后续程序扩展,考虑一行一条语句进行变量声明，需人工辅助重构,9,9
============================================================
2020-05-08 14:55:11:zw6666
重构失败的文件:
重构信息：
文件名,问题名,问题类型,问题评注,重构信息,起始行,终止行

